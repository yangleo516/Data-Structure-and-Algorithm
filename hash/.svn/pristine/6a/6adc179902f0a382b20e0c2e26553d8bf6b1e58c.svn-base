//
// STRINGTABLE.JAVA
// A hash table mapping Strings to their positions in the the pattern sequence
// You get to fill in the methods for this part.
//

public class StringTable {
    public static Record[] table;
    public int counter = 0;
    //
    // Create an empty table big enough to hold maxSize records.
    //
/*    public StringTable(int maxSize) 
    {
    	table = new Record[maxSize];
    } */
    
//    public void initialize(){
      public StringTable(int maxSize){
    	table = new Record[2];
    }
    
    public void doubleTable(){
    	table = new Record[table.length * 2];
    }
    
    //
    // Insert a Record r into the table.  Return true if
    // successful, false if the table is full.  You shouldn't ever
    // get two insertions with the same key value, but you may
    // simply return false if this happens.
    //
    public boolean insert(Record r) 
    { 
    	int base = baseHash(toHashKey(r.key));
    	int step = stepHash(toHashKey(r.key));
    	int size = table.length;
    	int slot = base % size;
    	
//    	int counter = 0;
    	
    	for(int i = 0; i < size; i++){
    		r.hashValue = toHashKey(r.key);            // hashValue
    		if(table[slot] == null || table[slot].key.equals("deleted")){
    			table[slot] = r;
    			counter = counter + 1;                //
    			
    			System.out.println("Î±:" + Math.round((double)counter/table.length*100)/100.0 + 
    					"  # of slots: " + table.length +"   "+ " # of records: " + counter
    					+ "   Position in tale: "+slot+ "   Key: " + table[slot].key); 
    			
    			if((double)counter / table.length >= 0.25){
    				Record[] oldTable = table;
    				doubleTable();
    				reHash(oldTable);
				}
    			return true;
    		}
    		else{
    			slot = (slot + step % size) % size;
    		}
    	}
    	return false; 
    }
    
    public void reHash(Record[] oldTable){
    	
    	int base = 0;
		int step = 0;
		int slot = 0;
		
    	for(int i = 0; i < oldTable.length; i++){
			
			
    		if(oldTable[i] != null && oldTable[i].key != "deleted"){
    			
    			base = baseHash(toHashKey(oldTable[i].key));
    			step = stepHash(toHashKey(oldTable[i].key));
    			slot = base % table.length;
    			
    			for(int j = 0; j < table.length; j++){
    				if(table[slot] == null){
    					table[slot] = oldTable[i];
    					break;
    				}
    				else{
    					slot = (slot + step % table.length) % table.length;
    				}
    			}
    		}
    	}
    }
    
    //
    // Delete a Record r from the table.  Note that you'll have to
    // find the record first unless you keep some extra information
    // in the Record structure.
    //
    public void remove(Record r) 
    {
    	int base = baseHash(toHashKey(r.key));
    	int step = stepHash(toHashKey(r.key));
    	int size = table.length;
    	int slot = base % size;
    	for(int i = 0; i < size; i++){
    		if(table[slot].key != null){
    			if((table[slot].key).equals (r.key)){
        			table[slot].key = "deleted";
        			table[slot].positions.add(0);
    			}
    			else{
    				slot = (slot + step % size) % size;
    			}
    		}
    	}
    	
    }
    
    
    //
    // Find a record with a key matching the input.  Return the
    // record if it exists, or null if no matching record is found.
    //
    public Record find(String key) 
    {
    	int hashKey = toHashKey(key);
    	int base = baseHash(hashKey);
    	int step = stepHash(hashKey);
    	int size = table.length;
    	int slot = base % size;
    	for(int i = 0; i < size; i++){
    		if(table[slot] == null){
    			return null;
    		}
    		else{
    			if(table[slot].hashValue == hashKey){
    				if((table[slot].key).equals (key)){
        				return table[slot];
        			}
    			}
    			else{
    				slot = (slot + step % size) % size;
    			}
    		}
    	}
    	return null;
    }
    
    
    
    ///////////////////////////////////////////////////////////////////////
    
    
    // Convert a String key into an integer that serves as input to hash
    // functions.  This mapping is based on the idea of a linear-congruential
    // pesudorandom number generator, in which successive values r_i are 
    // generated by computing
    //    r_i = ( A * r_(i-1) + B ) mod M
    // A is a large prime number, while B is a small increment thrown in
    // so that we don't just compute successive powers of A mod M.
    //
    // We modify the above generator by perturbing each r_i, adding in
    // the ith character of the string and its offset, to alter the
    // pseudorandom sequence.
    //
    int toHashKey(String s)
    {
	int A = 1952786893;
	int B = 367257;
	int v = B;
	
	for (int j = 0; j < s.length(); j++)
	    {
		char c = s.charAt(j);
		v = A * (v + (int) c + j) + B;
	    }
	
	if (v < 0) v = -v;
	return v;
    }
    
    int baseHash(int hashKey)
    {
	// Fill in your own hash function here
    	double A = (Math.sqrt(3)) / 2; 
    	double h1 = Math.floor(table.length * (hashKey * A - Math.floor(hashKey * A)));
	return (int)h1;
    }
    
    int stepHash(int hashKey)
    {
	// Fill in your own hash function here
    	double A = (Math.sqrt(5)-1) / 2;
    	double h2 = Math.floor(table.length * (hashKey * A - Math.floor(hashKey * A)));
	return (int)h2;
    }
}
